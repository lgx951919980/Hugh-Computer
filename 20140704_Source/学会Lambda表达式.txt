匿名方法：在匿名方法的语法中，delegate表达式关键字是有点多余，因为编译器已经知道我们在奖方法赋值给委托。

从匿名到lambda表达式：删除delegate关键字，在参数列表和匿名方法主体这间放lambda运算符=>.(lambda运算读作“goes to”)
 例： MyDel del = delegate(int x)   { return x + 1;};  //匿名方法
      MyDel le1 =         (int x) =>{ return x + 1;};  //Lambda表达式

这种简单的转换简洁了一点，然而，编译器可以通过推断，允许我们更进一步简化Lambda表达，如下：
1.编译器还可以从委托的声明中知道委托参数的类型，因此lambda表达式允许我们省略类型参数，如le2.(带有类型的参数列表称为显示类型，省略类型的参数列表称为隐式类型)
2.如果只有一个隐式类型参数，我们可以省略周围的圆括号，如le3.
3.最后，lambad表达式允许表达式的主体是语句块或表达式，如果语句块包含了一个返回语句，我们可以将语句块替换为return关键字后的表达式，如le4.
MyDel del = delegate(int x)   { return x + 1;};  //匿名方法
MyDel le1 =         (int x) =>{ return x + 1;};  //Lambda表达式
MyDel le2 =             (x) =>{ return x + 1;};  //Lambda表达式
MyDel le3 =               x =>{ return x + 1;};  //Lambda表达式
MyDel le4 =               x =>         x + 1  ;  //Lambda表达式
这样看起来，是不是更简洁多了，更容易理解了，呵呵!

总结：有关lambda表达式的参数列表的要点如下，
1.lambda表达式参数列表中的参数必须在参数数量、类型和位置上与委托相匹配
2.表达式的参数列表中的参数不一定需要包含类型（如隐式类型），除非委托有ref或out参数―此时类型是必须的（如显式类型）
3.如果只有一个参数，并且隐式类型的，周围的圆括号可以被省略，否则它就是必须的。
4.如果没有参数，必须使用一组空的圆括号。
			